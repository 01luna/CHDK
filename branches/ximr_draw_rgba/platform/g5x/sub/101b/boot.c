/*
 * boot.c - auto-generated by CHDK code_gen2.
 */

#include "lolevel.h"
#include "platform.h"
#include "core.h"
#include "dryos31.h"

#include "camera_info.h"

const char * const new_sa = &_end;

// Forward declarations
extern void task_CaptSeq ();
extern void task_InitFileModules ();
//extern void task_MovieRecord();
extern void task_ExpDrv ();

/*----------------------------------------------------------------------
 CreateTask_spytask
 -----------------------------------------------------------------------*/
void
CreateTask_spytask ()
{
    _CreateTask ("SpyTask", 0x19, 0x2000, core_spytask, 0);
}

/*************************************************************/
/*
    Custom function called in mzrm_sendmsg via logging function pointer (normally disabled)
    Checks if called from function that is updating the Canon UI.
    Updates CHDK bitmap settings and sets flag to update CHDK UI.
*/
void __attribute__((naked,noinline))
debug_logging_my(char* fmt, ...)
{
    (void)fmt;  // unused parameter
    asm volatile (
            //LR = Return address
            "    ldr     r0, =mzrm_sendmsg_ret_adr\n"   // Is return address in mzrm_sendmsg function?
            "    cmp     r0, lr\n"
            "    beq     chk_msg_type\n"
            "exit_debug_logging_my:\n"
            "    bx      lr\n"

            "chk_msg_type:\n"
            // mzrm_sendmsg 'msg' value (2nd parameter, saved in r11)
            "    ldr     r1, [r11]\n"                   // message type
            "    cmp     r1, 0x25\n"                    // message type XimrExe
            "    beq     do_ui_update\n"
            "    cmp     r1, 0x26\n"                    // message type XimrExeGain
            "    bne     exit_debug_logging_my\n"
            "do_ui_update:\n"
            "    ldr     r0, [r11,0x0c]\n"              // address of Ximr context in 'msg'
            "    b       update_ui\n"
    );
}

/*
    Install and enable custom logging function for mzrm_sendmsg.
*/
void
patch_mzrm_sendmsg ()
{
    extern int debug_logging_flag;
    extern void (*debug_logging_ptr)(char* fmt, ...);

    // Each bit in debug_logging_flag enables logging in different areas of the firmware code - only set the bit required for mzrm logging.
    debug_logging_flag = 0x200;
    debug_logging_ptr = debug_logging_my;
}

/*************************************************************/
void __attribute__((naked,noinline))
CreateTask_my ()
{
    asm volatile (
            "    push   {r0}\n"
            //R3 = Pointer to task function to create

            "    ldr     r0, =task_CaptSeq\n" // DryOS original code function ptr.
            "    cmp     r0, r3\n" // is the given taskptr equal to our searched function?
            "    itt     eq\n" // EQ block
            "    ldreq   r3, =capt_seq_task\n" // if so replace with our task function base ptr.
            "    beq     exitHook\n" // below compares not necessary if this check has found something.

            "    ldr     r0, =task_ExpDrv\n"
            "    cmp     r0, R3\n"
            "    itt     eq\n"
            "    ldreq   r3, =exp_drv_task\n"
            "    beq     exitHook\n"

            //"    ldr     r0, =task_DvlpSeq\n"
            //"    cmp     r0, R3\n"
            //"    itt     eq\n"
            //"    LDREQ   r3, =developseq_task\n"
            //"    BEQ     exitHook\n"

            "    ldr     r0, =task_FileWrite\n"
            "    cmp     r0, R3\n"
            "    itt     eq\n"
            "    ldreq   r3, =filewritetask\n"
            "    beq     exitHook\n"

            //"    ldr     r0, =task_MovieRecord\n"
            //"    cmp     r0, R3\n"
            //"    itt     eq\n"
            //"    ldreq   r3, =movie_record_task\n"
            //"    beq     exitHook\n"

            "    ldr     r0, =task_TricInitTask\n"
            "    cmp     r0, r3\n"
            "    itt     eq\n"
            "    ldreq   r3, =task_TricInitTask_my\n"
            "    beq     exitHook\n"

            "    ldr     r0, =task_InitFileModules\n"
            "    cmp     r0, r3\n"
            "    it      eq\n"
            "    ldreq   r3, =init_file_modules_task\n"

            "exitHook:\n"
            // restore overwritten register(s)
            "    pop    {r0}\n"
            // Execute overwritten instructions from original code, then jump to firmware
            "    push.w  {r1, r2, r3, r4, r5, r6, r7, r8, sb, lr}\n"
            "    mov     r4, r0\n"
            "    ldr     r0, =0x00008164\n"
            "    ldr.w   pc, =(hook_CreateTask + 9) \n" // Continue in firmware, thumb bit set
            ".ltorg\n"
    );
}

/*************************************************************/

// *** TEMPORARY? workaround ***
// Init stuff to avoid asserts on cameras running DryOS r54+
// https://chdk.setepontos.com/index.php?topic=12516.0
// Execute this only once
void init_required_fw_features(void)
{
//    extern void _init_focus_eventflag();
//    _init_focus_eventflag();
//    extern void _init_nd_eventflag();
//    _init_nd_eventflag();
    extern int av_override_semaphore;
    extern int _CreateBinarySemaphoreStrictly(int x, int y);
    av_override_semaphore = _CreateBinarySemaphoreStrictly(0,0);
}

/*************************************************************/

extern int physw0_override;

/*----------------------------------------------------------------------
 boot()

 Main entry point for the CHDK code
 -----------------------------------------------------------------------*/

/*************************************************************/
//** boot @ 0xFC02000D, length=43 
void __attribute__((naked,noinline)) boot() {
asm volatile (
            "    movw    r0, #0x4000\n"
            "    movt    r0, #0\n"
            "    mov     sp, r0\n"
            "    bl      sub_fc02007e\n"
            "    ldr     r2, =0xc0242010\n"
            "    ldr     r1, [r2]\n"
            "    orr     r1, r1, #1\n"
            "    str     r1, [r2]\n"
            "    ldr     r0, =0xfcee2168\n"
            "    ldr     r1, =0x010e1000\n"
            "    ldr     r3, =0x010fbd18\n"
            "loc_fc02002a:\n"
            "    cmp     r1, r3\n"
            "    itt     lo\n"
            "    ldrlo   r2, [r0], #4\n"
            "    strlo   r2, [r1], #4\n"
            "    blo     loc_fc02002a\n"
            "    ldr     r0, =0x010e1000\n"
            "    ldr     r1, =0x0001ad18\n"
            "    bl      sub_fc150d5a\n" // dcache_clean_range
            "    ldr     r0, =0xfcefce80\n"
            "    ldr     r1, =0xbfe10800\n"
            "    ldr     r3, =0xbfe176a9\n"
            "loc_fc020046:\n"
            "    cmp     r1, r3\n"
            "    itt     lo\n"
            "    ldrlo   r2, [r0], #4\n"
            "    strlo   r2, [r1], #4\n"
            "    blo     loc_fc020046\n"

            // Install CreateTask patch
            "    adr     r0, patch_CreateTask\n" // Patch data
            "    ldm     r0, {r1,r2}\n" // Get two patch instructions
            "    ldr     r0, =hook_CreateTask\n" // Address to patch, thumb bit is clear in stubs_entry.S
            "    stm     r0, {r1,r2}\n" // Store patch instructions

            "    ldr     r0, =0xfceacaf4\n"
            "    ldr     r1, =0x00008000\n"
            "    ldr     r3, =0x0003d674\n"
            "loc_fc02005a:\n"
            "    cmp     r1, r3\n"
            "    itt     lo\n"
            "    ldrlo   r2, [r0], #4\n"
            "    strlo   r2, [r1], #4\n"
            "    blo     loc_fc02005a\n"
            "    ldr     r3, =0x0003d674\n"
            "    ldr     r1, =0x0039124c\n"
            "    mov.w   r2, #0\n"
            "loc_fc020070:\n"
            "    cmp     r3, r1\n"
            "    it      lo\n"
            "    strlo   r2, [r3], #4\n"
            "    blo     loc_fc020070\n"

            "    blx     patch_mzrm_sendmsg\n"

            "    b.w     sub_fc066258_my\n" // Patched (was loc_fc066258)

            ".align 4\n"
            "patch_CreateTask:\n"
            "    ldr.w   pc, [pc,#0]\n" // Do jump to absolute address CreateTask_my
            "    .long   CreateTask_my + 1\n" // has to be a thumb address
            ".ltorg\n"
);
}

/*************************************************************/
//** sub_fc066258_my @ 0xFC066259, length=60 
void __attribute__((naked,noinline)) sub_fc066258_my() {
    if (*(int*) (0xd20b0000 + 0x97 * 4) & 0x10000)
    {
        // see sub_FC0ECF20, sub_FC09B450
        // GPIO 0x10 (aka ON/OFF button) is not pressed -> play
        *(int*) (0x9c44 + 0x8) = 0x200000;
    }
    else
    {
        // GPIO 0x10 is pressed -> rec
        *(int*) (0x9c44 + 0x8) = 0x100000;
    }

asm volatile (
            "    push    {r4, lr}\n"
#if defined(CHDK_NOT_IN_CANON_HEAP)
            "    ldr     r4, =0x0039124c\n"
#else
            "    ldr     r4, =new_sa\n"             // +
            "    ldr     r4, [r4]\n" // +
#endif
            "    sub     sp, #0x78\n"
            "    ldr     r0, =0x006ce000\n"
            "    ldr     r1, =0x000b1fec\n"
            "    subs    r0, r0, r4\n"
            "    cmp     r0, r1\n"
            "    bhs     loc_fc06626a\n"
            "loc_fc066268:\n"
            "    b       loc_fc066268\n"
            "loc_fc06626a:\n"
            "    ldr     r1, =0x00008078\n"
            "    mov.w   r0, #0x80000\n"
            "    str     r0, [r1]\n"
            "    ldr     r1, =0x0000807c\n"
            "    ldr     r0, =0x42281000\n"
            "    str     r0, [r1]\n"
            "    ldr     r1, =0x00008080\n"
            "    ldr     r0, =0x42283000\n"
            "    str     r0, [r1]\n"
            "    movs    r1, #0x78\n"
            "    mov     r0, sp\n"
            "    blx     sub_fc34d25c\n" // j_bzero
            "    ldr     r0, =0x0060e000\n"
            "    mov.w   r1, #0xc0000\n"
            "    stm.w   sp, {r0, r1, r4}\n"
            "    ldr     r1, =0x00600014\n"
            "    subs    r2, r1, r4\n"
            "    strd    r2, r1, [sp, #0xc]\n"
            "    str     r0, [sp, #0x14]\n"
            "    movs    r0, #0x22\n"
            "    str     r0, [sp, #0x18]\n"
            "    movs    r0, #0xca\n"
            "    str     r0, [sp, #0x1c]\n"
            "    movw    r0, #0x2b0\n"
            "    str     r0, [sp, #0x20]\n"
            "    movs    r0, #0xfa\n"
            "    str     r0, [sp, #0x24]\n"
            "    movw    r0, #0x11a\n"
            "    str     r0, [sp, #0x28]\n"
            "    movs    r0, #0x85\n"
            "    str     r0, [sp, #0x2c]\n"
            "    movs    r0, #0x40\n"
            "    str     r0, [sp, #0x30]\n"
            "    movs    r0, #4\n"
            "    str     r0, [sp, #0x34]\n"
            "    movs    r0, #0\n"
            "    str     r0, [sp, #0x38]\n"
            "    movs    r0, #0x10\n"
            "    str     r0, [sp, #0x5c]\n"
            "    movs    r2, #0\n"
            "    lsls    r0, r0, #8\n"
            "    str     r0, [sp, #0x60]\n"
            "    ldr     r1, =sub_fc0663e8_my\n" // Patched (was 0xfc0663e9)
            "    asrs    r0, r0, #4\n"
            "    str     r0, [sp, #0x64]\n"
            "    lsls    r0, r0, #5\n"
            "    str     r0, [sp, #0x68]\n"
            "    mov     r0, sp\n"
            "    blx     sub_fc34c9b8\n"
            "    add     sp, #0x78\n"
            "    pop     {r4, pc}\n"
);
}

/*************************************************************/
//** sub_fc0663e8_my @ 0xFC0663E9, length=54 
void __attribute__((naked,noinline)) sub_fc0663e8_my() {
asm volatile (
            "    push    {r4, lr}\n"
            "    ldr     r4, =0xfc066490\n" //  *"/_term"
            "    bl      sub_fc0672e4\n"
            "    ldr     r0, =0x000080f0\n"
            "    ldr     r1, [r0]\n"
            "    ldr     r0, =0x00008078\n"
            "    ldr     r0, [r0]\n"
            "    adds    r0, #0x10\n"
            "    cmp     r1, r0\n"
            "    bhs     loc_fc066404\n"
            "    ldr     r0, =0xfc0664a0\n" //  *"USER_MEM size checking"
            "    bl      _err_init_task\n"
            "loc_fc066404:\n"
            "    bl      sub_fc150e34\n" // GetSRAndDisableInterrupt
            "    ldr     r1, =0xbfe10000\n"
            "    mov.w   r2, #-0x11111112\n"
            "    ldr     r3, =0xbfe10800\n"
            "loc_fc066410:\n"
            "    stm     r1!, {r2}\n"
            "    cmp     r1, r3\n"
            "    blo     loc_fc066410\n"
            "    bl      sub_fc150e46\n" // SetSR
            "    bl      sub_fc150f60\n"
            "    cmp     r0, #0\n"
            "    bge     loc_fc066428\n"
            "    ldr     r0, =0xfc0664c0\n" //  *"dmSetup"
            "    bl      _err_init_task\n"
            "loc_fc066428:\n"
            "    bl      sub_fc0674fc\n"
            "    cmp     r0, #0\n"
            "    bge     loc_fc066436\n"
            "    ldr     r0, =0xfc0664c8\n" //  *"termDriverInit"
            "    bl      _err_init_task\n"
            "loc_fc066436:\n"
            "    mov     r0, r4\n"
            "    bl      sub_fc06758a\n"
            "    cmp     r0, #0\n"
            "    bge     loc_fc066446\n"
            "    ldr     r0, =0xfc0664d8\n" //  *"termDeviceCreate"
            "    bl      _err_init_task\n"
            "loc_fc066446:\n"
            "    mov     r0, r4\n"
            "    bl      sub_fc066610\n"
            "    cmp     r0, #0\n"
            "    bge     loc_fc066456\n"
            "    ldr     r0, =0xfc0664ec\n" //  *"stdioSetup"
            "    bl      _err_init_task\n"
            "loc_fc066456:\n"
            "    bl      sub_fc066754\n"
            "    cmp     r0, #0\n"
            "    bge     loc_fc066464\n"
            "    ldr     r0, =0xfc0664f8\n" //  *"stdlibSetup"
            "    bl      _err_init_task\n"
            "loc_fc066464:\n"
            "    bl      sub_fc0ec8e0\n"
            "    cmp     r0, #0\n"
            "    bge     loc_fc066472\n"
            "    ldr     r0, =0xfc066504\n" //  *"extlib_setup"
            "    bl      _err_init_task\n"
            "loc_fc066472:\n"
            "    pop.w   {r4, lr}\n"
            "    b.w     sub_fc0667de_my\n" // Patched (was loc_fc0667de)
);
}

/*************************************************************/
//** sub_fc0667de_my @ 0xFC0667DF, length=20 
void __attribute__((naked,noinline)) sub_fc0667de_my() {
asm volatile (
            "    push    {r3, lr}\n"
            "    bl      sub_fc0668ec\n"
            "    bl      sub_fc088984\n" // IsNormalCameraMode_FW
            "    bl      sub_fc0ecf20_my\n" // -> power-on mode handling & startupchecks here (was sub_fc0ecf20)
            "    cbnz    r0, loc_fc0667f4\n"
            "    bl      sub_fc0668da\n"
            "loc_fc0667f2:\n"
            "    b       loc_fc0667f2\n"
            "loc_fc0667f4:\n"
            "    blx     sub_fc34ca10\n"
            "    ldr     r1, =0x006ce000\n"
            "    movs    r0, #0\n"
            "    bl      sub_fc3bf9a4\n" //  return 0
            "    movs    r3, #0\n"
            "    str     r3, [sp]\n"
            "    ldr     r3, =task_Startup_my\n" //  task_Startup // Patched (was 0xfc066779)
            "    movs    r2, #0\n"
            "    movs    r1, #0x19\n"
            "    ldr     r0, =0xfc06681c\n" //  *"Startup"
            "    blx     sub_fc34ce3c\n" // j_CreateTask
            "    movs    r0, #0\n"
            "    pop     {r3, pc}\n"
);
}

/*************************************************************/
//** sub_fc0ecf20_my @ 0xFC0ECF21, length=54 
void __attribute__((naked,noinline)) sub_fc0ecf20_my() {
asm volatile (
            "    push.w  {r3, r4, r5, r6, r7, r8, sb, sl, fp, lr}\n"
            "    movs    r4, #0\n"
            "    mov     sl, r0\n"
            "    mov     r6, r4\n"
            "    bl      sub_fc09b44c\n" //  return
            "    movs    r0, #0x97\n"
            "    bl      sub_fc09bcca\n"
            "    mov.w   r8, #1\n"
            "    bic.w   r7, r8, r0\n"
            "    mov     r5, r8\n"
            "    movs    r0, #0x8a\n"
            "    bl      sub_fc09bcca\n"
            "    bics    r5, r0\n"
            "    movs    r0, #0\n"
            "    bl      sub_fc09b448\n" //  return 0x1
            "    cbz     r0, loc_fc0ecf58\n"
            "    movs    r0, #0x98\n"
            "    bl      sub_fc09bcca\n"
            "    bic.w   r6, r8, r0\n"
            "loc_fc0ecf58:\n"
            "    movw    r0, #0x10e\n"
            "    bl      sub_fc09bcca\n"
            "    bic.w   sb, r8, r0\n"
            "    movs    r0, #1\n"
            "    bl      sub_fc09b448\n" //  return 0x1
            "    cbz     r0, loc_fc0ecf76\n"
            "    movs    r0, #2\n"
            "    bl      sub_fc09bcca\n"
            "    bic.w   r4, r8, r0\n"
            "loc_fc0ecf76:\n"
            "    cmp.w   sl, #0\n"
            "    beq     loc_fc0ecfa6\n"
            "    cbz     r5, loc_fc0ecf98\n"
            "    movs    r0, #0x5a\n"
            "    blx     sub_fc34d1b4\n" // j_SleepTask
            "    movs    r0, #0x8a\n"
            "    bl      sub_fc09bcca\n"
            "    bic.w   r5, r8, r0\n"
            "    mov     r7, r8\n"
            "    movs    r0, #0x97\n"
            "    bl      sub_fc09bcca\n"
            "    bics    r7, r0\n"
            "loc_fc0ecf98:\n"
            "    orr.w   r0, r7, r5\n"
            "    orr.w   r1, r6, sb\n"
            "    orrs    r0, r1\n"
            "    orrs    r0, r4\n"
//            "    beq     loc_fc0ecfba\n" //  return
            "loc_fc0ecfa6:\n"
            "    mov     r3, sb\n"
            "    mov     r2, r6\n"
            "    mov     r1, r5\n"
            "    mov     r0, r7\n"
            "    str     r4, [sp]\n"
//            "    bl      sub_fc09b450\n"
//            "    bl      sub_fc09b44e\n" //  return
            "    movs    r0, #1\n"
            "loc_fc0ecfba:\n"
            "    pop.w   {r3, r4, r5, r6, r7, r8, sb, sl, fp, pc}\n"
);
}

/*************************************************************/
//** task_Startup_my @ 0xFC066779, length=26 
void __attribute__((naked,noinline)) task_Startup_my() {
asm volatile (
            "    push    {r4, lr}\n"
            "    bl      sub_fc0c2dfc\n"
            "    bl      sub_fc0668b8\n"
            "    bl      sub_fc0ed2d0\n" //  return
            "    bl      sub_fc44f2f4\n"
            // added for SD card UHS detection https://chdk.setepontos.com/index.php?topic=13089.msg132583#msg132583
            "    bl      sub_010e1746\n" // ref in sub_010e1746 following SD1stInit create
//            "    bl      sub_fc0ed356\n" // - startdiskboot
            "    bl      sub_fc0b277e\n"
            "    bl      sub_fc0ed448\n"
            "    bl      sub_fc066a44\n"
            "    bl      sub_fc0669c0\n" // init_ex_drivers
            "    bl      sub_fc44f332\n"
            "    bl      sub_fc0a2498\n" // init_error_handlers
            "    bl      sub_fc0ed44e\n"
            "    bl      sub_fc0ece46_my\n" // -> taskcreate_physw (was sub_fc0ece46)
            "    bl      CreateTask_spytask\n"          // +
            "    bl      init_required_fw_features\n"   // + TODO: Check if needed on G5X
            "    bl      sub_fc2d2a06\n"
            "    bl      sub_fc0ed464\n"
            "    bl      sub_fc0ec9ac\n"
            "    bl      sub_fc0c29fc\n"
            "    bl      sub_fc0c2f62\n"
            "    bl      sub_fc0c2d4a\n"
            "    bl      sub_fc0c29b8\n"
            "    bl      sub_fc066a48\n" //  return
            "    bl      sub_fc3691d0\n"
            "    bl      sub_fc0c298a\n"
            "    pop.w   {r4, lr}\n"
            "    b.w     sub_fc0c2dd2\n" // jump to FW
);
}

/*************************************************************/
//** sub_fc0ece46_my @ 0xFC0ECE47, length=18 
void __attribute__((naked,noinline)) sub_fc0ece46_my() {
asm volatile (
            "    push    {r3, r4, r5, lr}\n"
            "    bl      sub_fc09da2c\n"
            "    bl      sub_fc088902\n" // IsFactoryMode_FW
            "    cbnz    r0, loc_fc0ece56\n"
            "    bl      sub_fc09d9d0\n" // OpLog.Start_FW
            "loc_fc0ece56:\n"
            "    ldr     r4, =0x000082d8\n" //  physw_run
            "    ldr     r0, [r4, #4]\n"
            "    cmp     r0, #0\n"
            "    bne     loc_fc0ece72\n" //  return
            "    movs    r3, #0\n"
            "    str     r3, [sp]\n"
            "    ldr     r3, =mykbd_task\n" //  task_PhySw // task_PhySw replacement (was 0xfc0ece21)
            "    movs    r1, #0x17\n"
            "    ldr     r0, =0xfc0ed1c8\n" //  *"PhySw"
            "    movw    r2, #0x2000\n" // Increase stack size (was 0x800)
            "    blx     sub_fc34d0b4\n" // j_CreateTaskStrictly
            "    str     r0, [r4, #4]\n"
            "loc_fc0ece72:\n"
            "    pop     {r3, r4, r5, pc}\n"
);
}

/*************************************************************/
//** init_file_modules_task @ 0xFC157609, length=18 
void __attribute__((naked,noinline)) init_file_modules_task() {
asm volatile (
            "    push    {r4, r5, r6, lr}\n"
            "    movs    r0, #6\n"
            "    bl      sub_fc368a2c\n" //  return
            "    bl      sub_fc0c994c\n"
            "    movs    r4, r0\n"
            "    movw    r5, #0x5006\n"
            "    beq     loc_fc157624\n"
            "    movs    r1, #0\n"
            "    mov     r0, r5\n"
            "    bl      _PostLogicalEventToUI\n"
            "loc_fc157624:\n"
            "    bl      sub_fc0c9976_my\n" // Patched (was sub_fc0c9976)
            "    bl      core_spytask_can_start\n" // + CHDK: Set "it's-safe-to-start" flag for spytask
            "    cmp     r4, #0\n"
            "    bne     loc_fc157638\n" //  return
            "    mov     r0, r5\n"
            "    pop.w   {r4, r5, r6, lr}\n"
            "    movs    r1, #1\n"
            "    b.w     _PostLogicalEventToUI\n"
            "loc_fc157638:\n"
            "    pop     {r4, r5, r6, pc}\n"
);
}

/*************************************************************/
//** sub_fc0c9976_my @ 0xFC0C9977, length=4 jfw
void __attribute__((naked,noinline)) sub_fc0c9976_my() {
asm volatile (
            "    movs    r0, #3\n"
            "    push    {r4, lr}\n"
            "    bl      sub_fc3b7158_my\n" // Patched (was sub_fc3b7158)
            "    ldr     pc, =0xfc0c997f\n" // Continue in firmware
);
}

/*************************************************************/
//** sub_fc3b7158_my @ 0xFC3B7159, length=26 jfw
void __attribute__((naked,noinline)) sub_fc3b7158_my() {
asm volatile (
            "    push.w  {r4, r5, r6, r7, r8, lr}\n"
            "    mov     r6, r0\n"
            "    bl      sub_fc3b712a\n"
            "    ldr     r1, =0x00044368\n"
            "    mov     r5, r0\n"
            "    add.w   r4, r1, r0, lsl #7\n"
            "    ldr     r0, [r4, #0x6c]\n"
            "    lsls    r0, r0, #0x1d\n"
            "    bpl     loc_fc3b717e\n"
            "    movw    r2, #0xa7d\n"
            "    ldr     r1, =0xfc3b6bf0\n" //  *"Mounter.c"
            "    movs    r0, #0\n"
            "    blx     sub_fc34d264\n" // j_DebugAssert
            "loc_fc3b717e:\n"
            "    mov     r1, r6\n"
            "    mov     r0, r5\n"
            "    bl      sub_fc3b6a6c\n"
            "    ldr     r0, [r4, #0x38]\n"
            "    bl      sub_fc3b76a6\n"
            "    cbnz    r0, loc_fc3b7192\n"
            "    movs    r0, #0\n"
            "    str     r0, [r4, #0x6c]\n"
            "loc_fc3b7192:\n"
            "    mov     r0, r5\n"
            "    bl      sub_fc3b6ac4\n"
            "    mov     r0, r5\n"
            "    bl      sub_fc3b6d26_my\n" // Patched (was sub_fc3b6d26)
            "    ldr     pc, =0xfc3b719f\n" // Continue in firmware
);
}

/*************************************************************/
//** sub_fc3b6d26_my @ 0xFC3B6D27, length=11 jfw
void __attribute__((naked,noinline)) sub_fc3b6d26_my() {
asm volatile (
            "    push    {r4, r5, r6, lr}\n"
            "    mov     r5, r0\n"
            "    ldr     r0, =0x00044368\n"
            "    add.w   r4, r0, r5, lsl #7\n"
            "    ldr     r0, [r4, #0x6c]\n"
            "    lsls    r0, r0, #0x1e\n"
            "    bmi     sub_fc3b6d58\n" //  return 0x1 // jump to FW
            "    ldr     r0, [r4, #0x38]\n"
            "    mov     r1, r5\n"
            "    bl      sub_fc3b6b22_my\n" // Patched (was sub_fc3b6b22)
            "    ldr     pc, =0xfc3b6d3f\n" // Continue in firmware
);
}

/*************************************************************/
//** sub_fc3b6b22_my @ 0xFC3B6B23, length=108 
void __attribute__((naked,noinline)) sub_fc3b6b22_my() {
asm volatile (
            "    push.w  {r4, r5, r6, r7, r8, sb, sl, lr}\n"
            "    mov     sl, r0\n"
            "    ldr     r0, =0x00044368\n"
            "    mov.w   r8, #0\n"
            "    add.w   r5, r0, r1, lsl #7\n"
            "    mov     r6, r8\n"
            "    mov     sb, r8\n"
            "    ldr     r0, [r5, #0x3c]\n"
            "    cmp     r0, #7\n"
            "    bhs     loc_fc3b6c1c\n"
            "    tbb     [pc, r0]\n" // (jumptable r0 7 elements)
            "branchtable_fc3b6b40:\n"
            "    .byte((loc_fc3b6b58 - branchtable_fc3b6b40) / 2)\n" // (case 0)
            "    .byte((loc_fc3b6b48 - branchtable_fc3b6b40) / 2)\n" // (case 1)
            "    .byte((loc_fc3b6b48 - branchtable_fc3b6b40) / 2)\n" // (case 2)
            "    .byte((loc_fc3b6b48 - branchtable_fc3b6b40) / 2)\n" // (case 3)
            "    .byte((loc_fc3b6b48 - branchtable_fc3b6b40) / 2)\n" // (case 4)
            "    .byte((loc_fc3b6c18 - branchtable_fc3b6b40) / 2)\n" // (case 5)
            "    .byte((loc_fc3b6b48 - branchtable_fc3b6b40) / 2)\n" // (case 6)
            ".align 1\n"
            "loc_fc3b6b48:\n"
            "    movs    r2, #0\n"
            "    movw    r1, #0x200\n"
            "    movs    r0, #2\n"
            "    bl      _exmem_ualloc\n"
            "    movs    r4, r0\n"
            "    bne     loc_fc3b6b5e\n"
            "loc_fc3b6b58:\n"
            "    movs    r0, #0\n"
            "loc_fc3b6b5a:\n"
            "    pop.w   {r4, r5, r6, r7, r8, sb, sl, pc}\n"
            "loc_fc3b6b5e:\n"
            "    ldr     r7, [r5, #0x50]\n"
            "    movs    r2, #1\n"
            "    movs    r1, #0\n"
            "    mov     r3, r4\n"
            "    mov     r0, sl\n"
            "    blx     r7\n"
            "    cmp     r0, #1\n"
            "    bne     loc_fc3b6b76\n"
            "    movs    r0, #2\n"
            "    bl      _exmem_ufree\n"
            "    b       loc_fc3b6b58\n" //  return 0
            "loc_fc3b6b76:\n"
            "    ldr     r1, [r5, #0x64]\n"
            "    mov     r0, sl\n"
            "    blx     r1\n"

"    mov     r1, r4\n"              //  pointer to MBR in r1
"    bl      mbr_read_dryos\n"      //  total sectors count in r0 before and after call

// Start of DataGhost's FAT32 autodetection code (Digic6+ version by philmoz)
// Policy: If there is a partition which has type FAT32 or exFat, use the first one of those for image storage
// According to the code below, we can use r1, r2, r3 and r12.
// LR wasn't really used anywhere but for storing a part of the partition signature. This is the only thing
// that won't work with an offset, but since we can load from LR+offset into LR, we can use this to do that :)
"    mov     r7, r4\n"              // Copy the MBR start address so we have something to work with
"    mov     lr, r4\n"              // Save old offset for MBR signature
"    mov     r1, #1\n"              // Note the current partition number
"    b       dg_sd_fat32_enter\n"   // We actually need to check the first partition as well, no increments yet!
"dg_sd_fat32:\n"
"    cmp     r1, #4\n"              // Did we already see the 4th partition?
"    beq     dg_sd_fat32_end\n"     // Yes, break. We didn't find anything, so don't change anything.
"    add     r7, r7, #0x10\n"       // Second partition
"    add     r1, r1, #1\n"          // Second partition for the loop
"dg_sd_fat32_enter:\n"
"    ldrb.w  r2, [r7, #0x1BE]\n"    // Partition status
"    ldrb.w  r3, [r7, #0x1C2]\n"    // Partition type (FAT32 = 0xB)
"    cmp     r3, #0xB\n"            // Is this a FAT32 partition?
"    beq     dg_sd_valid\n"
"    cmp     r3, #0xC\n"            // Not 0xB, is it 0xC (FAT32 LBA) then?
"    beq     dg_sd_valid\n"
"    cmp     r3, #0x7\n"            // exFat?
"    bne     dg_sd_fat32\n"         // No, it isn't. Loop again.
"dg_sd_valid:\n"
"    cmp     r2, #0x00\n"           // It is, check the validity of the partition type
"    beq     dg_sd_ok\n"
"    cmp     r2, #0x80\n"
"    bne     dg_sd_fat32\n"         // Invalid, go to next partition
"dg_sd_ok:\n"
                                    // This partition is valid, it's the first one, bingo!
"    mov     r4, r7\n"              // Move the new MBR offset for the partition detection.

"dg_sd_fat32_end:\n"
// End of DataGhost's FAT32 autodetection code

            "    ldr.w   r2, [r4, #0x1c7]\n"
            "    mov     r1, r0\n"
            "    ldrb.w  r0, [r4, #0x1c6]\n"
            "    ldr.w   r7, [r4, #0x1cb]\n"
            "    orr.w   r0, r0, r2, lsl #8\n"
            "    ldrb.w  r2, [r4, #0x1ca]\n"
            "    ldrb.w  r3, [r4, #0x1be]\n"
            "    orr.w   r2, r2, r7, lsl #8\n"
//            "    ldrb.w  r7, [r4, #0x1fe]\n" // replaced below
//            "    ldrb.w  r4, [r4, #0x1ff]\n" // replaced below
            "    ldrb.w  r7, [lr, #0x1fe]\n"    // replace instructions above
            "    ldrb.w  r4, [lr, #0x1ff]\n"    // replace instructions above
            "    cbz     r3, loc_fc3b6ba8\n"
            "    cmp     r3, #0x80\n"
            "    bne     loc_fc3b6bba\n"
            "loc_fc3b6ba8:\n"
            "    cmp     r1, r0\n"
            "    blo     loc_fc3b6bba\n"
            "    adds    r3, r0, r2\n"
            "    cmp     r3, r1\n"
            "    bhi     loc_fc3b6bba\n"
            "    cmp     r7, #0x55\n"
            "    bne     loc_fc3b6bba\n"
            "    cmp     r4, #0xaa\n"
            "    beq     loc_fc3b6bfc\n"
            "loc_fc3b6bba:\n"
            "    mov     r4, sb\n"
            "    b       loc_fc3b6c02\n"
            "    b       loc_fc3b6c1c\n"
            "    str     r5, [r2, #0x7c]\n"
            "    ldc2    p13, c10, [fp], #-0x20\n"
            "    movs    r0, r0\n"
            "    muls    r0, r5, r0\n"
            "    movs    r4, r0\n"
            "    ldr     r3, [r1]\n"
            "    ldc2    p6, c7, [fp], #-0x1bc\n"
            "    strb    r5, [r4, #9]\n"
            "    strb    r2, [r6, r0]\n"
            "    lsrs    r2, r0, #9\n"
            "    movs    r0, r0\n"
            "    movs    r0, r0\n"
            "    cmp     r3, #0xcf\n"
            "    lsls    r6, r1, #4\n"
            "    cmp     r4, #0x81\n"
            "    lsls    r6, r1, #4\n"
            "    cmp     r2, #0x61\n"
            "    lsls    r6, r1, #4\n"
            "    cmp     r5, #0x9b\n"
            "    lsls    r6, r1, #4\n"
            "    cmp     r3, #0xc1\n"
            "    lsls    r6, r1, #4\n"
            "    ldr     r5, [r1, #0x74]\n"
            "    ldr     r5, [r6, #0x64]\n"
            "    str     r4, [r6, #0x54]\n"
            "    cmp     r6, #0x72\n"
            "    lsls    r3, r4, #1\n"
            "    movs    r0, r0\n"
            "loc_fc3b6bfc:\n"
            "    movs    r4, #1\n"
            "    mov     r8, r0\n"
            "    mov     r6, r2\n"
            "loc_fc3b6c02:\n"
            "    movs    r0, #2\n"
            "    bl      _exmem_ufree\n"
            "    cbnz    r4, loc_fc3b6c2a\n"
            "    ldr     r1, [r5, #0x64]\n"
            "    mov.w   r8, #0\n"
            "    mov     r0, sl\n"
            "    blx     r1\n"
            "    mov     r6, r0\n"
            "    b       loc_fc3b6c2a\n"
            "loc_fc3b6c18:\n"
            "    movs    r6, #0x40\n"
            "    b       loc_fc3b6c2a\n"
            "loc_fc3b6c1c:\n"
            "    movw    r2, #0x689\n"
            "    ldr     r1, =0xfc3b6bf0\n" //  *"Mounter.c"
            "    movs    r0, #0\n"
            "    blx     sub_fc34d264\n" // j_DebugAssert
            "loc_fc3b6c2a:\n"
            "    strd    r6, sb, [r5, #0x48]\n"
            "    movs    r0, #1\n"
            "    str.w   r8, [r5, #0x44]\n"
            "    b       loc_fc3b6b5a\n" //  return
);
}

/*************************************************************/
//** kbd_p2_f_my @ 0xFC0ECB7D, length=77 
void __attribute__((naked,noinline)) kbd_p2_f_my() {
asm volatile (
            "    push.w  {r4, r5, r6, r7, r8, lr}\n"
            "    ldr     r6, =0x0003ef70\n"
            "    sub     sp, #0x18\n"
            "    add     r7, sp, #8\n"
            "    subs    r6, #0xc\n"
            "    b       loc_fc0ecbbe\n"
            "loc_fc0ecb8a:\n"
            "    ldr     r1, =0x0003ef70\n"
            "    add     r3, sp, #8\n"
            "    ldrb.w  r0, [sp, #4]\n"
            "    add     r2, sp, #0x14\n"
            "    subs    r1, #0x18\n"
            "    bl      sub_fc09bb10\n"
            "    cbnz    r0, loc_fc0ecba4\n"
            "    ldr     r1, [sp, #0x14]\n"
            "    movs    r0, #0\n"
            "    bl      sub_fc0ecaee\n"
            "loc_fc0ecba4:\n"
            "    movs    r0, #2\n"
            "loc_fc0ecba6:\n"
            "    ldr.w   r1, [r7, r0, lsl #2]\n"
            "    cbz     r1, loc_fc0ecbb6\n"
            "    ldr.w   r2, [r6, r0, lsl #2]\n"
            "    bics    r2, r1\n"
            "    str.w   r2, [r6, r0, lsl #2]\n"
            "loc_fc0ecbb6:\n"
            "    subs    r0, r0, #1\n"
            "    sxtb    r0, r0\n"
            "    cmp     r0, #0\n"
            "    bge     loc_fc0ecba6\n"
            "loc_fc0ecbbe:\n"
            "    ldr     r0, =0x0003ef70\n"
            "    add     r1, sp, #4\n"
            "    subs    r0, #0xc\n"
            "    bl      sub_fc09b7f6\n"
            "    cmp     r0, #0\n"
            "    bne     loc_fc0ecb8a\n"
            "    ldr.w   r8, =0x0003ef70\n"
            "    movs    r4, #0\n"
            "loc_fc0ecbd2:\n"
            "    movs    r5, #0\n"
            "    ldr.w   r0, [r6, r4, lsl #2]\n"
            "    ldr.w   r1, [r8, r4, lsl #2]\n"
            "    ands    r0, r1\n"
            "    str.w   r0, [r6, r4, lsl #2]\n"
            "    b       loc_fc0ecc2a\n"
            "loc_fc0ecbe4:\n"
            "    lsrs    r0, r5\n"
            "    lsls    r0, r0, #0x1f\n"
            "    beq     loc_fc0ecc22\n"
            "    ldr     r1, =0x0003ef70\n"
            "    add.w   r0, r5, r4, lsl #5\n"
            "    add     r3, sp, #8\n"
            "    subs    r1, #0x18\n"
            "    add     r2, sp, #0x14\n"
            "    uxtb    r0, r0\n"
            "    bl      sub_fc09bb10\n"
            "    cbnz    r0, loc_fc0ecc06\n"
            "    ldr     r1, [sp, #0x14]\n"
            "    movs    r0, #1\n"
            "    bl      sub_fc0ecaee\n"
            "loc_fc0ecc06:\n"
            "    mov     r0, r4\n"
            "    b       loc_fc0ecc1e\n"
            "loc_fc0ecc0a:\n"
            "    ldr.w   r1, [r7, r0, lsl #2]\n"
            "    cbz     r1, loc_fc0ecc1a\n"
            "    ldr.w   r2, [r6, r0, lsl #2]\n"
            "    bics    r2, r1\n"
            "    str.w   r2, [r6, r0, lsl #2]\n"
            "loc_fc0ecc1a:\n"
            "    adds    r0, r0, #1\n"
            "    sxtb    r0, r0\n"
            "loc_fc0ecc1e:\n"
            "    cmp     r0, #3\n"
            "    blt     loc_fc0ecc0a\n"
            "loc_fc0ecc22:\n"
            "    ldr.w   r0, [r6, r4, lsl #2]\n"
            "    adds    r5, r5, #1\n"
            "    uxtb    r5, r5\n"
            "loc_fc0ecc2a:\n"
            "    cmp     r0, #0\n"
            "    bne     loc_fc0ecbe4\n"
            "    adds    r4, r4, #1\n"
            "    sxtb    r4, r4\n"
            "    cmp     r4, #3\n"
            "    blt     loc_fc0ecbd2\n"
            "    bl      sub_fc09b570_my\n" // Patched (was sub_fc09b570)
            "    add     sp, #0x18\n"
            "    pop.w   {r4, r5, r6, r7, r8, pc}\n"
);
}

/*************************************************************/
//** sub_fc09b570_my @ 0xFC09B571, length=14 
void __attribute__((naked,noinline)) sub_fc09b570_my() {
asm volatile (
            "    push    {r4, lr}\n"
            "    ldr     r4, =0x00009c44\n"
            "    ldr     r0, [r4, #0xc]\n"
            "    bl      sub_fc0a3b54\n"
            "    ldr     r0, [r4, #0x10]\n"
            "    bl      sub_fc0a3bde\n"
            "    bl      sub_fc0a3c66\n"
            "    bl      sub_fc10b3f4\n"
            "    ldr     r0, [r4, #0x14]\n"
            "    bl      sub_fc0a3a84\n"
            "    ldr     r0, [r4, #0x18]\n"
            "    bl      sub_fc0a3a84\n"

            "    bl      handle_jogdial\n" // +
            "    cmp     r0, #0\n" // +
            "    beq     no_scroll\n" // +

            "    pop.w   {r4, lr}\n"
            "    b.w     sub_fc0a3fc2\n" // jump to FW

            "no_scroll:\n" // +
            "    pop     {r4, pc}\n" // +
);
}

/*************************************************************/
//** kbd_p1_f_cont_my @ 0xFC0ED153, length=19 jfw
void __attribute__((naked,noinline)) kbd_p1_f_cont_my() {
asm volatile (
            "    ldr     r3, =0x0003ef4c\n" //  physw_status
            "    movs    r0, #2\n"
            "    mov     r5, sp\n"
            "    add.w   r6, r3, #0x24\n"
            "loc_fc0ed15c:\n"
            "    add.w   r1, r6, r0, lsl #2\n"
            "    ldr.w   r2, [r3, r0, lsl #2]\n"
            "    ldr     r7, [r1, #0xc]\n"
            "    ldr     r1, [r1, #0x18]\n"
            "    and.w   r2, r2, r7\n"
            "    eor.w   r2, r2, r1\n"
            "    str.w   r2, [r5, r0, lsl #2]\n"
            "    subs    r0, r0, #1\n"
            "    bpl     loc_fc0ed15c\n"
            "    ldr     r2, =0x0003ef4c\n" //  physw_status
            "    mov     r0, sp\n"
            "    adds    r2, #0x18\n"
            "    sub.w   r1, r2, #0xc\n"
            "    bl      sub_fc0ecc40_my\n" // -> some physical status is re-read here (not into physw_status) (was sub_fc0ecc40)
            "    ldr     pc, =0xfc0ed187\n" // Continue in firmware
);
}

/*************************************************************/
//** sub_fc0ecc40_my @ 0xFC0ECC41, length=5 jfw
void __attribute__((naked,noinline)) sub_fc0ecc40_my() {
asm volatile (
            "    push.w  {r0, r1, r2, r3, r4, r5, r6, r7, r8, sb, sl, fp, ip, lr}\n"
            "    ldr     r4, =0x0003ef70\n"
            "    mov     r5, r0\n"
            "    ldr     r0, =physw0_override\n" // +
            "    ldr.w   r0, [r0]\n" // + use CHDK override value
//            "    mov.w   r0, #-1\n" // -
            "    ldr     pc, =0xfc0ecc4d\n" // Continue in firmware
);
}

/*************************************************************/
//** task_TricInitTask_my @ 0xFC542289, length=35 
void __attribute__((naked,noinline)) task_TricInitTask_my() {
asm volatile (
            "    push.w  {r0, r1, r2, r3, r4, r5, r6, r7, r8, sb, sl, fp, ip, lr}\n"
            "    movs    r0, #8\n"
            "    ldr     r1, =0xfc5424b4\n" //  *"InitTskStart"
            "    bl      sub_fc3b782e\n"
            "    ldr.w   sl, =0x000222dc\n"
            "    movw    fp, #0x1000\n"
            "    ldr     r4, =0x000222d8\n"
            "    movs    r2, #0\n"
            "    ldr     r1, =0x0703870f\n"
            "    ldr     r0, [r4]\n"
            "    blx     sub_fc34d22c\n" // j_WaitForAnyEventFlag
            "    lsls    r0, r0, #0x1f\n"
            "    beq     loc_fc5422be\n"
            "    movs    r0, #8\n"
            "    ldr     r1, =0xfc5424cc\n" //  *"ER IniTskWait"
            "    bl      sub_fc3b788e\n"
            "    ldr     r1, =0x000222c4\n"
            "    movs    r0, #0\n"
            "    str     r0, [r1]\n"
            "    pop.w   {r0, r1, r2, r3, r4, r5, r6, r7, r8, sb, sl, fp, ip, pc}\n"
            "loc_fc5422be:\n"
            "    ldr     r4, =0x000222d8\n"
            "    add     r1, sp, #0xc\n"
            "    ldr     r0, [r4]\n"
            "    blx     sub_fc34d014\n" // j_GetEventFlagValue
            "    ldr     r1, [sp, #0xc]\n"
            "    ldr     r0, [r4]\n"
            "    blx     sub_fc34d1e4\n" // j_ClearEventFlag
            "    ldr     r0, =0x02000003\n"
            "    ldr     r7, [sp, #0xc]\n"
            "    tst     r7, r0\n"
            "    beq     sub_fc5423c2\n" // jump to FW
            "    lsls    r0, r7, #0x1f\n"
            "    beq     sub_fc5422e2\n" // jump to FW

            "    ldr     r0, =0xd2020074\n" // +
            "    ldr     r0, [r0]\n"        // + nonzero when core already running
            "    subs    r0, #0\n"          // +
            "    beq     tric1\n"           // +
            "    ldr     r0, [r4]\n"        // +
            "    mov     r1, #0x80\n"       // +
            "    bl      _SetEventFlag\n"   // + core already initialized, set the SmacIdleCmp eventflag here
            "tric1:\n"                      // +

            "    bl      sub_fc542766\n"
            "    b       sub_fc54234e\n" // jump to FW
);
}
